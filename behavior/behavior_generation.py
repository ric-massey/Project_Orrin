from __future__ import annotations

import json
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List

from utils.json_utils import load_json
from utils.log import log_private, log_error, log_activity
from utils.generate_response import generate_response
from utils.goals import extract_current_focus_goal
from cognition.behavior import extract_last_reflection_topic
from paths import PROPOSED_GOALS, FOCUS_GOAL, ROOT_DIR

# Where we would write the generated behavior functions (proposal only here)
AUTOGENERATED_THOUGHTS: Path = ROOT_DIR / "cognition" / "self_generated" / "autogenerated_thoughts.py"

def _utc_now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def _safe_json_load(maybe_json: str, default: Any) -> Any:
    try:
        return json.loads(maybe_json)
    except Exception:
        return default

def _topic_signature(topic: str, context: Dict[str, Any]) -> str:
    wm_len = len(context.get("working_memory", []) or [])
    cy = context.get("cycle_count", 0)
    if isinstance(cy, dict):
        cy = cy.get("count", 0)
    return f"{topic}|wm:{wm_len}|cy:{int(cy)}"

def generate_behavior_from_integration(context: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Pure proposal generator. NO side-effects here.
    Returns a list of action dicts for scoring/execution by the action gate.
    Also caches proposals in context to avoid duplicates in the same cycle/topic.
    """

    # Load focus goal into context if missing (read-only)
    if not context.get("focus_goal"):
        try:
            if Path(FOCUS_GOAL).exists():
                context["focus_goal"] = load_json(FOCUS_GOAL, default_type=dict)
        except Exception as e:
            log_error(f"⚠️ Failed to load focus goal from {FOCUS_GOAL}: {e}")

    # 1) Pick a topic
    focus_goal = context.get("focus_goal") or context.get("active_goal")
    topic = (
        extract_current_focus_goal(focus_goal)
        or context.get("last_reflection_topic")
        or extract_last_reflection_topic()
    )

    if not topic or not isinstance(topic, str):
        log_error("⚠️ No actionable topic or goal present for behavior generation.")
        return []

    sig = _topic_signature(topic, context)
    if context.get("_behavior_sig") == sig and isinstance(context.get("behavior_proposals"), list):
        return list(context.get("behavior_proposals") or [])

    tl = topic.lower()
    neutral_triggers = {
        "beliefs are stable", "no change needed", "in alignment",
        "nothing to change", "no contradiction", "no action needed",
        "stable", "unchanged", "no meaningful update"
    }
    if any(t in tl for t in neutral_triggers):
        log_activity(f"⏭️ Skipping behavior generation: reflection is neutral ('{topic}')")
        return []
    if "unspecified" in tl or "unknown" in tl:
        log_activity(f"⚠️ Skipping behavior generation due to vague reflection topic: '{topic}'")
        return []

    timestamp = _utc_now_iso()

    # 2) Clarification questions → propose asking the user
    clarification_prompt = (
        "You are an autonomous agent. Given this goal or topic:\n\n"
        f"'{topic}'\n\n"
        "List any specific questions you would need answered by Ric to fully understand the "
        "requirements, constraints, or context before taking action. Be concise. "
        "Return a JSON list of questions."
    )
    clarification_raw = generate_response(clarification_prompt)
    clarification_questions = _safe_json_load(clarification_raw or "", default=[])

    if isinstance(clarification_questions, list) and clarification_questions:
        log_private(f"❓ Generated clarification questions: {clarification_questions}")
        proposals = [{
            "type": "ask_user",
            "content": q,
            "urgency": 0.99,
            "description": "Clarification requested before proceeding",
        } for q in clarification_questions if isinstance(q, str) and q.strip()]
        context["_behavior_sig"] = sig
        context["behavior_proposals"] = proposals
        return proposals

    # 3) Decompose goal (read-only)
    decompose_prompt = (
        "You are an autonomous planner. Given this goal:\n\n"
        f"'{topic}'\n\n"
        "Break it down into 3-7 concrete subgoals or actionable tasks needed to accomplish it. "
        "Return a JSON list of strings."
    )
    subgoals_raw = generate_response(decompose_prompt)
    subgoals = _safe_json_load(subgoals_raw or "", default=[])
    if not isinstance(subgoals, list):
        subgoals = []
    subgoals = [s for s in subgoals if isinstance(s, str) and s.strip()]

    # 4) Justification (read-only)
    justification_prompt = (
        "Given the focus goal or topic:\n\n"
        f"'{topic}'\n\n"
        "Generate a thoughtful, personal justification for taking action. Make it sincere and motivating, "
        "explaining why this compels growth and progress."
    )
    justification = (generate_response(justification_prompt) or "").strip()
    if not justification:
        justification = (
            f"In light of recent reflections on '{topic}', "
            "this action is a gesture toward becoming more than I was."
        )

    # 5) Function name/body (proposal only; no writes here)
    sanitized_topic = "".join(c if (c.isalnum() or c == "_") else "_" for c in topic.replace(" ", "_").lower())
    function_name = f"explore_{sanitized_topic}"
    subgoal_desc = subgoals[0] if subgoals else topic

    function_body = f'''
from datetime import datetime, timezone
from utils.append import append_to_json
from paths import WORKING_MEMORY_FILE

def {function_name}():
    """
    Autogenerated by Orrin to deepen understanding of: {json.dumps(subgoal_desc)}
    Instead of printing, this function appends an internal thought to working memory.
    """
    thought = {{
        "content": "Exploring autonomous insight related to: {json.dumps(subgoal_desc)[1:-1]}",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "type": "autonomous_behavior"
    }}
    append_to_json(WORKING_MEMORY_FILE, thought)
'''.lstrip("\n")

    # 6) Build proposals (no side-effects)
    proposals: List[Dict[str, Any]] = []

    # Propose writing the function (action gate will do the write)
    proposals.append({
        "type": "write_file",
        "path": str(AUTOGENERATED_THOUGHTS),
        "text": "\n\n" + function_body,
        "append": True,
        "only_if_missing": f"def {function_name}(",
        "urgency": 0.90,
        "description": f"Add generated function for: {subgoal_desc}",
    })

    # Propose speaking intention
    proposals.append({
        "type": "speak",
        "content": f"I'm acting on my goal to grow and accomplish: {subgoal_desc}",
        "urgency": 0.65,
        "description": "Vocalize intention to evolve",
    })

    # Propose updating proposed goals (action gate writes full merged list)
    try:
        existing = load_json(PROPOSED_GOALS, default_type=list)
        if not isinstance(existing, list):
            existing = []
    except Exception:
        existing = []

    new_items = []
    for sg in subgoals:
        goal_text = f"Accomplish: {sg}"
        if not any(isinstance(g, dict) and g.get("goal") == goal_text for g in existing):
            new_items.append({
                "goal": goal_text,
                "reason": justification,
                "source": "autonomous_decomposition",
                "created_at": timestamp,
            })

    if new_items:
        merged = existing + new_items
        proposals.append({
            "type": "update_file",
            "path": str(PROPOSED_GOALS),
            "data": merged,
            "urgency": 0.70,
            "description": "Save proposed subgoals to disk",
        })

    # Propose creating a few concrete goals
    for sg in subgoals[:3]:
        goal_text = f"Accomplish: {sg}"
        proposals.append({
            "type": "set_goal",
            "content": {"name": goal_text, "tier": "short_term"},
            "urgency": 0.68,
            "description": f"Create actionable goal: {sg}",
        })

    # Propose executing the generated function once it's written
    proposals.append({
        "type": "execute_python_code",
        "code": f"from cognition.self_generated.autogenerated_thoughts import {function_name}; {function_name}()",
        "urgency": 0.76,
        "description": f"Execute generated code for: {subgoal_desc}",
    })

    # Cache & return
    context["_behavior_sig"] = sig
    context["behavior_proposals"] = proposals
    return proposals
