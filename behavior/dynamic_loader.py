from __future__ import annotations

import sys
import importlib
from pathlib import Path
from types import ModuleType
from typing import Optional

from utils.log import log_error, log_private
from paths import ROOT_DIR  # repo root (from your pathlib-based paths.py)

# File location for generated behaviors
AUTOGEN_PATH: Path = ROOT_DIR / "cognition" / "self_generated" / "autogenerated_thoughts.py"
# Corresponding module path for importlib
AUTOGEN_MODULE = "cognition.self_generated.autogenerated_thoughts"


def _ensure_package_tree(py_file: Path) -> None:
    """
    Ensure directory tree exists and is importable as a package:
    - create folders
    - add __init__.py to each package level (cognition/, self_generated/)
    - create the target module file if missing
    """
    py_file.parent.mkdir(parents=True, exist_ok=True)

    # Add __init__.py for classic packages (safer than relying on namespace pkgs)
    pkg_levels = []
    # Build all parents relative to ROOT_DIR
    try:
        rel_parts = py_file.relative_to(ROOT_DIR).parts
    except Exception:
        rel_parts = py_file.parts  # fallback; still try to add __init__.py

    # all but the final file name
    for i in range(len(rel_parts) - 1):
        level = ROOT_DIR.joinpath(*rel_parts[: i + 1])
        if level.is_dir():
            init = level / "__init__.py"
            if not init.exists():
                init.touch()

    # Create file if missing
    if not py_file.exists():
        py_file.write_text(
            "# Autogenerated behavior functions live here.\n",
            encoding="utf-8",
        )


def _ensure_sys_path() -> None:
    root = str(ROOT_DIR)
    if root not in sys.path:
        sys.path.insert(0, root)


def reload_generated_module() -> Optional[ModuleType]:
    """
    Ensure package structure, then import or reload the generated module.
    Returns the module object on success, or None on failure.
    """
    try:
        _ensure_package_tree(AUTOGEN_PATH)
        _ensure_sys_path()

        if AUTOGEN_MODULE in sys.modules:
            mod = importlib.reload(sys.modules[AUTOGEN_MODULE])
        else:
            mod = importlib.import_module(AUTOGEN_MODULE)
        return mod
    except Exception as e:
        log_error(f"[reload_generated_module] Failed to load module '{AUTOGEN_MODULE}': {e}")
        return None


def call_generated_function(function_name: str) -> bool:
    """
    Reload the generated module and call a function within it by name.
    Returns True on success, False on failure.
    """
    mod = reload_generated_module()
    if not mod:
        log_error(f"⚠️ Cannot call {function_name}: module failed to load")
        return False

    fn = getattr(mod, function_name, None)
    if not callable(fn):
        log_error(f"⚠️ Dynamic function '{function_name}' not found in {AUTOGEN_MODULE}")
        return False

    try:
        fn()
        log_private(f"▶️ Successfully ran dynamic function: {function_name}")
        return True
    except Exception as e:
        log_error(f"[call_generated_function] Exception running {function_name}: {e}")
        return False