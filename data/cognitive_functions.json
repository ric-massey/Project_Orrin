[
  {
    "name": "add_goal",
    "definition": "add_goal(goal: 'Dict', parent_name: 'Optional[str]' = None) -> 'Dict'"
  },
  {
    "name": "adjust_goal_weights",
    "definition": "adjust_goal_weights(context: 'Dict[str, Any] | None' = None) -> 'None'\nUse recent feedback to nudge priorities on upcoming actions/goals.\n    Writes trajectory snapshots to GOAL_TRAJECTORY_LOG_JSON."
  },
  {
    "name": "adjust_priority",
    "definition": "adjust_priority(goal: 'Dict[str, Any]', fb: 'Dict[str, Any]') -> 'None'"
  },
  {
    "name": "bootstrap_self",
    "definition": "bootstrap_self() -> 'str'\nOrrin reflects on latest tools/ideas and simulates improvements\n    to its own bootstrapping process."
  },
  {
    "name": "build_system_prompt",
    "definition": "build_system_prompt(self_model=None)"
  },
  {
    "name": "check_violates_boundaries",
    "definition": "check_violates_boundaries(prompt)\nReturn a list of boundary rules that the prompt appears to violate.\n    Returns [] when no violations are found, and None only on hard failure.\n    Supports string rules (substring match). If a rule dict has {\"regex\": \"...\"},\n    it will be applied as a regex."
  },
  {
    "name": "clean_snippet",
    "definition": "clean_snippet(text: Any) -> str\nTrim to ~60 chars without cutting mid-word. Robust to non-str input."
  },
  {
    "name": "compose_dream",
    "definition": "compose_dream(self_model: Dict[str, Any], recent: List[Any]) -> str\nReturn a symbolic dream text based on self_model and recent thoughts."
  },
  {
    "name": "create_micro_goal_for_action",
    "definition": "create_micro_goal_for_action(action_desc: 'str', parent_name: 'Optional[str]' = None) -> 'Dict'"
  },
  {
    "name": "curiosity_loop",
    "definition": "curiosity_loop() -> 'str | None'"
  },
  {
    "name": "decompose_goal",
    "definition": "decompose_goal(goal: 'Dict') -> 'List[Dict]'\nUse the LLM to break a complex goal into actionable subgoals."
  },
  {
    "name": "ensure_immediate_actions_bucket",
    "definition": "ensure_immediate_actions_bucket(goals: 'List[Dict]') -> 'Dict'"
  },
  {
    "name": "ensure_long_term_goal",
    "definition": "ensure_long_term_goal(goals: 'List[Dict]') -> 'List[Dict]'"
  },
  {
    "name": "eval_predicate",
    "definition": "eval_predicate(expr: 'str', context: 'Dict[str, Any]') -> 'bool'\nVery small, safe evaluator.\n    Supported:\n      - AND / OR (case-insensitive)\n      - Comparisons: <=, >=, ==, <, >\n      - Regex match: lhs~=\"pattern\"   (Python re.search)\n      - Bare key truthiness: e.g., completed\n    Notes:\n      - Parentheses are NOT supported.\n      - Do not put AND/OR inside quoted strings."
  },
  {
    "name": "evaluate_new_abstractions",
    "definition": "evaluate_new_abstractions() -> 'str'"
  },
  {
    "name": "evaluate_recent_cognition",
    "definition": "evaluate_recent_cognition()"
  },
  {
    "name": "evolve_core_value",
    "definition": "evolve_core_value(self_model: dict) -> str\nForce Orrin to invent or mutate a core value for growth. Returns log string."
  },
  {
    "name": "explore_your_recent_emotional_states_listlessness__security__and",
    "definition": "explore_your_recent_emotional_states_listlessness__security__and()\nAutogenerated by Orrin to deepen understanding of: 'Your recent emotional statesâ€”listlessness, security, and'"
  },
  {
    "name": "explore_your_recent_thoughts_reflect_mild_emotional",
    "definition": "explore_your_recent_thoughts_reflect_mild_emotional()\nAutogenerated by Orrin to deepen understanding of: 'Your recent thoughts reflect mild emotional'"
  },
  {
    "name": "explore_your_recent_thoughts_remain_consistent_with_your",
    "definition": "explore_your_recent_thoughts_remain_consistent_with_your()\nAutogenerated by Orrin to deepen understanding of: 'Your recent thoughts remain consistent with your'"
  },
  {
    "name": "explore_your_recent_thoughts_reveal_mild_emotional_ambivalence_and",
    "definition": "explore_your_recent_thoughts_reveal_mild_emotional_ambivalence_and()\nAutogenerated by Orrin to deepen understanding of: 'Your recent thoughts reveal mild emotional ambivalence and'"
  },
  {
    "name": "extract_last_reflection_topic",
    "definition": "extract_last_reflection_topic(context: Optional[Dict[str, Any]] = None, reflection_log_path: str = PosixPath('/Users/ricmassey/orrin/Original_Orrin/data/reflection_log.json')) -> str\nAttempts to find the most recent reflection topic from:\n    1. Working memory entries tagged with reflection-related types.\n    2. Reflection log file.\n    3. Emotional state fallback."
  },
  {
    "name": "generate_absurd_goal",
    "definition": "generate_absurd_goal(context)"
  },
  {
    "name": "generate_concepts_from_memories",
    "definition": "generate_concepts_from_memories()\nExtracts emergent concepts from memory using reflection."
  },
  {
    "name": "goal_function_already_exists",
    "definition": "goal_function_already_exists(goal_tree: 'Optional[List[Dict]]', function_name: 'Optional[str]') -> 'bool'\nCheck if tokens of function_name appear in goal text/history anywhere in the tree."
  },
  {
    "name": "imagine_opposite_self",
    "definition": "imagine_opposite_self(context)"
  },
  {
    "name": "introspective_planning",
    "definition": "introspective_planning() -> 'Dict[str, Any]'"
  },
  {
    "name": "invent_new_value",
    "definition": "invent_new_value(context)"
  },
  {
    "name": "load_goals",
    "definition": "load_goals() -> 'List[Dict]'"
  },
  {
    "name": "load_neutral_count",
    "definition": "load_neutral_count() -> int"
  },
  {
    "name": "mark_goal_completed",
    "definition": "mark_goal_completed(goal: 'Dict') -> 'None'"
  },
  {
    "name": "mark_goal_status_by_name",
    "definition": "mark_goal_status_by_name(name: 'str', new_status: 'str') -> 'bool'"
  },
  {
    "name": "maybe_complete_goals",
    "definition": "maybe_complete_goals() -> 'bool'\nTraverses the full goal tree.\n    - Marks goals as completed if all subgoals are completed.\n    - Logs and rewards each completion.\n    - Saves updated goals back to GOALS_FILE and appends to COMPLETED_GOALS_FILE."
  },
  {
    "name": "merge_updated_goal_into_tree",
    "definition": "merge_updated_goal_into_tree(tree: 'List[Dict]', updated: 'Dict') -> 'List[Dict]'\nMerge an updated goal node into the full tree by matching (name, timestamp) or name.\n    Replaces the first match found; recurses into subgoals. If not found, appends at top level."
  },
  {
    "name": "meta_reflect",
    "definition": "meta_reflect(context: dict = None)"
  },
  {
    "name": "moral_override_check",
    "definition": "moral_override_check(proposed_action: str) -> dict\nAsk the thinking model whether a proposed action violates core memories/values/beliefs/stances.\n    Returns a dict like {\"override\": bool, \"reason\": \"...\"}."
  },
  {
    "name": "mutate_directive",
    "definition": "mutate_directive(context)"
  },
  {
    "name": "now_iso",
    "definition": "now_iso() -> 'str'"
  },
  {
    "name": "periodic_self_review",
    "definition": "periodic_self_review(n_events: 'int' = 400) -> 'None'"
  },
  {
    "name": "plan_self_evolution",
    "definition": "plan_self_evolution() -> 'str'\nGenerate a self-evolution roadmap and register steps as subgoals."
  },
  {
    "name": "prune_goals",
    "definition": "prune_goals(goals: 'List[Dict]') -> 'List[Dict]'"
  },
  {
    "name": "prune_old_threads",
    "definition": "prune_old_threads(max_default_days: 'int' = 14, max_default_threads: 'int' = 10) -> 'str'"
  },
  {
    "name": "pursue_goal",
    "definition": "pursue_goal(goal: 'Dict') -> 'None'"
  },
  {
    "name": "record_decision",
    "definition": "record_decision(fn_name, reason)"
  },
  {
    "name": "reflect_as_agents",
    "definition": "reflect_as_agents(topic: 'Optional[str]' = None, context: 'Optional[Dict[str, Any]]' = None) -> 'Optional[Dict[str, Any]]'\nInvokes internal agent dialogue about a topic.\n    If topic isn't provided, infer it from persisted context.\n    Returns {\"agent_responses\": [...], \"synthesis\": \"...\"} or None."
  },
  {
    "name": "reflect_on_cognition_patterns",
    "definition": "reflect_on_cognition_patterns(n: 'int' = 50) -> 'Optional[str]'\nAnalyze recent cognition history to identify usage patterns, over/under-used functions,\n    and shifting focus. Returns the plain-text summary on success; None on no data/error."
  },
  {
    "name": "reflect_on_cognition_schedule",
    "definition": "reflect_on_cognition_schedule()\nAdjust Orrin's cognitive rhythm using statistical meta-reflection and higher-order LLM insight.\n    Combines usage/satisfaction scoring with full memory introspection."
  },
  {
    "name": "reflect_on_conversation_patterns",
    "definition": "reflect_on_conversation_patterns()"
  },
  {
    "name": "reflect_on_effectiveness",
    "definition": "reflect_on_effectiveness(log: bool = True)"
  },
  {
    "name": "reflect_on_emotion_sensitivity",
    "definition": "reflect_on_emotion_sensitivity()\nAdjusts Orrin's emotion sensitivity profile based on recent emotional triggers.\n    More intense emotions lead to dampening; less intense emotions increase sensitivity."
  },
  {
    "name": "reflect_on_growth_history",
    "definition": "reflect_on_growth_history()"
  },
  {
    "name": "reflect_on_internal_agents",
    "definition": "reflect_on_internal_agents() -> 'Optional[bool]'\nReviews existing internal agents within Orrin's self-model and updates their current views.\n    Ignores/repairs any agents that are not proper dicts.\n    Returns True if an update was written, False/None otherwise."
  },
  {
    "name": "reflect_on_internal_voices",
    "definition": "reflect_on_internal_voices() -> 'Optional[bool]'\nScans recent thoughts for emergent internal voices and registers them as agents if found.\n    Returns True if a new agent was added; False/None otherwise."
  },
  {
    "name": "reflect_on_missed_goals",
    "definition": "reflect_on_missed_goals()"
  },
  {
    "name": "reflect_on_outcomes",
    "definition": "reflect_on_outcomes()\nReflect on recent unreviewed outcomes, log insights, optionally update beliefs,\n    and mark those outcomes as reflected in the on-disk OUTCOMES_JSON without truncating it."
  },
  {
    "name": "reflect_on_prompts",
    "definition": "reflect_on_prompts()\nAllows Orrin to revise, remove, or add new reflection prompts based on evolving identity.\n    Tracks changes with backups and updates working memory with a clear log."
  },
  {
    "name": "reflect_on_rules_used",
    "definition": "reflect_on_rules_used()\nReflects on recent memory outcomes to assess the effectiveness of Orrin's causal reasoning rules.\n    Updates rules by adding, revising, or removing entries as appropriate."
  },
  {
    "name": "reflect_on_sandbox_experiment",
    "definition": "reflect_on_sandbox_experiment(context)\nReflect on the impact of a recent sandbox experiment and log the results\n    to both working and long-term memory using the new memory conventions."
  },
  {
    "name": "reflect_on_self_beliefs",
    "definition": "reflect_on_self_beliefs()"
  },
  {
    "name": "reflect_on_think",
    "definition": "reflect_on_think()\nReads the think_module code and evaluates it introspectively against Orrin's model and goals."
  },
  {
    "name": "resolve_conflicts",
    "definition": "resolve_conflicts()"
  },
  {
    "name": "run_sandbox_experiments",
    "definition": "run_sandbox_experiments(context=None)\nOrrin enters a 'sandbox' and runs 1â€“3 random experiments.\n    All actions, results, and self-evaluations are logged to SANDBOX_LOG."
  },
  {
    "name": "save_goals",
    "definition": "save_goals(goals: 'List[Dict]') -> 'None'"
  },
  {
    "name": "save_neutral_count",
    "definition": "save_neutral_count(count: int) -> None"
  },
  {
    "name": "select_focus_goals",
    "definition": "select_focus_goals() -> 'Dict[str, Optional[Dict]]'\nLoad goals, select focus goals, and write to FOCUS_GOAL.\n    Returns the focus goal dictionary."
  },
  {
    "name": "self_model_maintenance_cycle",
    "definition": "self_model_maintenance_cycle() -> 'None'"
  },
  {
    "name": "self_supervised_repair",
    "definition": "self_supervised_repair() -> 'str'"
  },
  {
    "name": "simulate_conflicting_beliefs",
    "definition": "simulate_conflicting_beliefs(context)"
  },
  {
    "name": "simulate_event",
    "definition": "simulate_event(event)\nSimulates outcomes of a hypothetical event within Orrinâ€™s world model."
  },
  {
    "name": "simulate_future_selves",
    "definition": "simulate_future_selves(save_to_history: 'bool' = True) -> 'Dict[str, Any]'\nSimulate three possible future versions of self.\n    Returns { \"futures\": [], \"preferred\": \"\", \"reason\": \"\" } and optionally logs to EVOLUTION_FUTURES."
  },
  {
    "name": "simulate_new_cognitive_abilities",
    "definition": "simulate_new_cognitive_abilities() -> 'str'\nImagine and propose a hypothetical new cognitive tool/abstraction\n    based on the self-model + recent reflections. Appends to PROPOSED_TOOLS_JSON."
  },
  {
    "name": "simulate_world_state_change",
    "definition": "simulate_world_state_change(change_description: 'str') -> 'Dict[str, Any] | None'"
  },
  {
    "name": "summarize_relationships",
    "definition": "summarize_relationships(relationships)"
  },
  {
    "name": "tag_beliefs_from_feedback",
    "definition": "tag_beliefs_from_feedback()"
  },
  {
    "name": "try_to_accomplish",
    "definition": "try_to_accomplish(goal: 'Dict') -> 'bool'\nPlug in your LLM/tool integration for atomic actions.\n    Returns True if succeeded, False if needs decomposition."
  },
  {
    "name": "update_and_select_focus_goals",
    "definition": "update_and_select_focus_goals() -> 'Dict[str, Optional[Dict]]'"
  },
  {
    "name": "update_cognition_schedule",
    "definition": "update_cognition_schedule(new_schedule: 'Dict[str, Any]') -> 'Optional[bool]'\nMerge a partial schedule dict into the persisted cognition schedule.\n    Returns:\n      True  -> changes were applied\n      False -> no meaningful change\n      None  -> bad input or routed error"
  },
  {
    "name": "update_influence_scores_from_feedback",
    "definition": "update_influence_scores_from_feedback(increment: 'float' = 0.05) -> 'str'"
  },
  {
    "name": "update_motivations",
    "definition": "update_motivations() -> 'None'\nReflect on recent thoughts and core values, revise motivations in self_model."
  },
  {
    "name": "update_relationship_model",
    "definition": "update_relationship_model(context)"
  },
  {
    "name": "update_self_model",
    "definition": "update_self_model()"
  },
  {
    "name": "update_values_with_lessons",
    "definition": "update_values_with_lessons() -> None\nMine long-term memory for repeated lessons and promote them into self_model.core_values\n    when seen at least twice. Appends a log entry on change."
  },
  {
    "name": "update_world_model",
    "definition": "update_world_model()\nReflectively updates Orrinâ€™s internal world model from recent thoughts."
  }
]