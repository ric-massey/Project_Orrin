[
  {
    "name": "add_tool_to_catalog",
    "definition": "add_tool_to_catalog(name: 'str', description: 'str', when_to_use: 'str') -> 'None'"
  },
  {
    "name": "call_generated_function",
    "definition": "call_generated_function(function_name: 'str') -> 'bool'\nReload the generated module and call a function within it by name.\n    Returns True on success, False on failure."
  },
  {
    "name": "delay_between_requests",
    "definition": "delay_between_requests() -> 'None'"
  },
  {
    "name": "evaluate_tool_use",
    "definition": "evaluate_tool_use(memories: 'List[Dict[str, Any]]') -> 'None'\nVery simple keyword-based suggester that appends to TOOL_REQUESTS_FILE."
  },
  {
    "name": "execute_pending_tools",
    "definition": "execute_pending_tools()"
  },
  {
    "name": "execute_python_code",
    "definition": "execute_python_code(code_string: 'str', *, timeout: 'float' = 5.0, cwd: 'str | None' = None) -> 'Dict[str, Any]'\nExecute Python code in an *isolated subprocess* (sandbox).\n    Returns:\n      {\n        \"success\": bool,\n        \"output\": \"<stdout>\",\n        \"stderr\": \"<stderr>\",\n        \"returncode\": int\n      }"
  },
  {
    "name": "filter_memories",
    "definition": "filter_memories(memories, tag='[MemoryFilter]')\nFilter input list to only dicts, logging any weird entries."
  },
  {
    "name": "generate_behavior_from_integration",
    "definition": "generate_behavior_from_integration(context: 'Dict[str, Any]') -> 'List[Dict[str, Any]]'\nPure proposal generator. NO side-effects here.\n    Returns a list of action dicts for scoring/execution by the action gate.\n    Also caches proposals in context to avoid duplicates in the same cycle/topic."
  },
  {
    "name": "get_all_memories",
    "definition": "get_all_memories()"
  },
  {
    "name": "is_scraping_allowed",
    "definition": "is_scraping_allowed(url: 'str') -> 'bool'"
  },
  {
    "name": "load_private_thoughts_as_list",
    "definition": "load_private_thoughts_as_list(path)\nParse PRIVATE_THOUGHTS_FILE into a list of dicts with {timestamp, content}."
  },
  {
    "name": "read_file",
    "definition": "read_file(path: 'str | Path') -> 'Dict[str, Any]'\nRead a text file (utf-8). Relative paths resolve under DATA_DIR."
  },
  {
    "name": "reflect_on_result",
    "definition": "reflect_on_result(tool, reason, result)"
  },
  {
    "name": "reload_generated_module",
    "definition": "reload_generated_module() -> 'Optional[ModuleType]'\nEnsure package structure, then import or reload the generated module.\n    Returns the module object on success, or None on failure."
  },
  {
    "name": "revise_think",
    "definition": "revise_think() -> 'str'\nReflectively rewrite think() using recent thoughts, internal state, and past results.\n    Writes a validated revision into THINK_MODULE with a backup, after sandbox verification."
  },
  {
    "name": "run_python_sandboxed",
    "definition": "run_python_sandboxed(code: 'str', *, dry_run: 'bool' = False, timeout_s: 'int' = 5) -> 'dict'"
  },
  {
    "name": "run_tool",
    "definition": "run_tool(tool, reason)"
  },
  {
    "name": "scrape_text",
    "definition": "scrape_text(url: 'str') -> 'str'\nRespect robots.txt, then fetch and return ~first 2000 chars of visible text."
  },
  {
    "name": "tool_thinking",
    "definition": "tool_thinking() -> 'None'\nAsk the model to propose tool uses based on recent memories.\n    Appends merged suggestions to TOOL_REQUESTS_FILE."
  },
  {
    "name": "utc_now_iso",
    "definition": "utc_now_iso() -> 'str'"
  },
  {
    "name": "web_search",
    "definition": "web_search(query: 'str') -> 'Dict[str, Any]'\nUses Serper.dev (requires SERPER_API_KEY in env).\n    Correct usage: POST with JSON body, not GET."
  },
  {
    "name": "write_file",
    "definition": "write_file(path: 'str | Path', content: 'str') -> 'Dict[str, Any]'\nWrite arbitrary text to a file (atomic). Relative paths resolve under DATA_DIR."
  }
]