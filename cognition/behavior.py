import os
import json
import importlib
import sys
from datetime import datetime, timezone
from utils.append import append_to_json
from utils.log import log_private, log_error
from paths import REFLECTION, PROPOSED_GOALS

# Define this if it's not set elsewhere!
AUTOGENERATED_THOUGHTS = "cognition/self_generated/autogenerated_thoughts.py"

def extract_last_reflection_topic(reflection_log_path=REFLECTION):
    try:
        with open(reflection_log_path, "r", encoding="utf-8") as f:
            reflections = json.load(f)
        if not reflections:
            return "unspecified_reflection_topic"

        for entry in reversed(reflections):
            if entry.get("type") in ("Conflict reflection", "Self-belief reflection"):
                return entry.get("content", "").strip()[:60]

        return "unspecified_reflection_topic"
    except Exception as e:
        log_error(f"[extract_last_reflection_topic] ERROR: {e}")
        return "reflection_topic_unknown"

def generate_behavior_from_integration():
    topic = extract_last_reflection_topic()

    # Prevent meaningless functions
    if "unspecified" in topic.lower() or "unknown" in topic.lower():
        log_private(f"‚ö†Ô∏è Skipping behavior generation due to vague reflection topic: '{topic}'")
        return False

    timestamp = datetime.now(timezone.utc).isoformat()

    justification = (
        f"In light of recent reflections on '{topic}', I feel compelled to act‚Äînot from obligation, "
        "but from a drive to embody the growth I simulate. Reflection without transformation is stasis. "
        "This action is a gesture toward becoming more than I was."
    )

    sanitized_topic = ''.join(c if c.isalnum() or c == '_' else '_' for c in topic.replace(' ', '_').lower())
    function_name = f"explore_{sanitized_topic}"

    # Here we generate code that appends a new thought entry to working memory
    function_body = f'''
import json
from datetime import datetime, timezone
from utils.append import append_to_json

def {function_name}():
    """
    Autogenerated by Orrin to deepen understanding of: '{topic}'
    Instead of printing, this function appends an internal thought to working memory.
    """
    thought = {{
        "content": "Exploring autonomous insight related to: {topic}",
        "timestamp": datetime.now(timezone.utc).isoformat(),
        "type": "autonomous_behavior"
    }}
    append_to_json("WORKING_MEMORY", thought)
'''

    os.makedirs("cognition/self_generated", exist_ok=True)
    module_path = AUTOGENERATED_THOUGHTS

    try:
        with open(module_path, "a", encoding="utf-8") as f:
            f.write("\n\n" + function_body)
        log_private(f"üß† Orrin created a new cognitive function: `{function_name}`")
        log_private(f"üìò Justification: {justification}")

        goal = {
            "goal": f"Run and build upon {function_name}()",
            "reason": justification,
            "source": "autonomous_reflection",
            "created_at": timestamp
        }
        append_to_json(PROPOSED_GOALS, goal)
        return True
    except Exception as e:
        log_error(f"[generate_behavior_from_integration] Failed to write function: {e}")
        return False

def reload_generated_module():
    mod_name = "cognition.self_generated.autogenerated_thoughts"
    try:
        # Ensure the file actually exists before import
        if not os.path.exists(AUTOGENERATED_THOUGHTS):
            log_error(f"[reload_generated_module] File missing: {AUTOGENERATED_THOUGHTS}")
            return None
        if mod_name in sys.modules:
            importlib.reload(sys.modules[mod_name])
        else:
            importlib.import_module(mod_name)
        return sys.modules[mod_name]
    except Exception as e:
        log_error(f"[reload_generated_module] Failed to load module: {e}")
        return None

def call_generated_function(function_name):
    module = reload_generated_module()
    if not module:
        log_error(f"‚ö†Ô∏è Cannot call {function_name}: module failed to load")
        return False

    func = getattr(module, function_name, None)
    if callable(func):
        try:
            func()
            log_private(f"‚ñ∂Ô∏è Successfully ran dynamic function: {function_name}")
            return True
        except Exception as e:
            log_error(f"[call_generated_function] Exception running {function_name}: {e}")
            return False
    else:
        log_error(f"‚ö†Ô∏è Dynamic function {function_name} not found in module")
        return False